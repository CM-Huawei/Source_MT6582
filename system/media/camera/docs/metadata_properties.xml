<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright (C) 2012 The Android Open Source Project

     Licensed under the Apache License, Version 2.0 (the "License");
     you may not use this file except in compliance with the License.
     You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

     Unless required by applicable law or agreed to in writing, software
     distributed under the License is distributed on an "AS IS" BASIS,
     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
     limitations under the License.
-->
<metadata xmlns="http://schemas.android.com/service/camera/metadata/"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://schemas.android.com/service/camera/metadata/ metadata_properties.xsd">

  <tags>
    <tag id="AWB">
        Needed for auto white balance
    </tag>
    <tag id="BC">
        Needed for backwards compatibility with old Java API
    </tag>
    <tag id="V1">
        New features for first camera 2 release (API1)
    </tag>
    <tag id="ADV">
      <!-- TODO: fill the tag description -->
    </tag>
    <tag id="DNG">
        Needed for DNG file support
    </tag>
    <tag id="EXIF">
      <!-- TODO: fill the tag description -->
    </tag>
    <tag id="HAL2">
        Entry is only used by camera device HAL 2.x
    </tag>
    <tag id="FULL">
        Entry is required for full hardware level devices, and optional for other hardware levels
    </tag>
  </tags>

  <types>
    <typedef name="rectangle">
      <language name="java">android.graphics.Rect</language>
    </typedef>
    <typedef name="size">
      <language name="java">android.hardware.camera2.Size</language>
    </typedef>
    <typedef name="string">
      <language name="java">String</language>
    </typedef>
    <typedef name="boolean">
      <language name="java">boolean</language>
    </typedef>
    <typedef name="imageFormat">
      <language name="java">int</language>
    </typedef>
  </types>

  <namespace name="android">
    <section name="colorCorrection">
      <controls>
        <entry name="mode" type="byte" visibility="public" enum="true">
          <enum>
            <value>TRANSFORM_MATRIX
              <notes>Use the android.colorCorrection.transform matrix
              and android.colorCorrection.gains to do color conversion</notes>
            </value>
            <value>FAST
              <notes>Must not slow down frame rate relative to raw
              bayer output</notes>
            </value>
            <value>HIGH_QUALITY
              <notes>Frame rate may be reduced by high
              quality</notes>
            </value>
          </enum>

          <notes>When android.control.awbMode is not OFF, TRANSFORM_MATRIX
          should be ignored.</notes>
        </entry>
        <entry name="transform" type="rational" visibility="public"
               type_notes="3x3 rational matrix in row-major order"
               container="array">
          <array>
            <size>3</size>
            <size>3</size>
          </array>
          <description>A color transform matrix to use to transform
          from sensor RGB color space to output linear sRGB color space
          </description>
          <range>Output values are expected to be in the range
          (0,1)</range>
          <notes>This matrix is either set by HAL when the request
          android.colorCorrection.mode is not TRANSFORM_MATRIX, or
          directly by the application in the request when the
          android.colorCorrection.mode is TRANSFORM_MATRIX.

          In the latter case, the HAL may round the matrix to account
          for precision issues; the final rounded matrix should be
          reported back in this matrix result metadata.</notes>
        </entry>
        <entry name="gains" type="float" visibility="public"
               type_notes="A 1D array of floats for 4 color channel gains"
               container="array">
          <array>
            <size>4</size>
          </array>
          <description>Gains applying to Bayer color channels for
          white-balance</description>
          <notes>The 4-channel white-balance gains are defined in
          the order of [R G_even G_odd B], where G_even is the gain
          for green pixels on even rows of the output, and G_odd
          is the gain for greenpixels on the odd rows. if a HAL
          does not support a separate gain for even/odd green channels,
          it should use the G_even value,and write G_odd equal to
          G_even in the output result metadata.

          This array is either set by HAL when the request
          android.colorCorrection.mode is not TRANSFORM_MATRIX, or
          directly by the application in the request when the
          android.colorCorrection.mode is TRANSFORM_MATRIX.

          The ouput should be the gains actually applied by the HAL to
          the current frame.</notes>
        </entry>
      </controls>
      <dynamic>
        <clone entry="android.colorCorrection.transform" kind="controls">
        </clone>
        <clone entry="android.colorCorrection.gains" kind="controls">
        </clone>
      </dynamic>
    </section>
    <section name="control">
      <controls>
        <entry name="aeAntibandingMode" type="byte" visibility="public"
               enum="true" >
          <enum>
            <value>OFF</value>
            <value>50HZ</value>
            <value>60HZ</value>
            <value>AUTO</value>
          </enum>
          <description>Enum for controlling
          antibanding</description>
          <range>
          android.control.aeAvailableAntibandingModes</range>
        </entry>
        <entry name="aeExposureCompensation" type="int32" visibility="public">
          <description>Adjustment to AE target image
          brightness</description>
          <units>count of positive/negative EV steps</units>
          <notes>For example, if EV step is 0.333, '6' will mean an
          exposure compensation of +2 EV; -3 will mean an exposure
          compensation of -1</notes>
          <tag id="BC" />
        </entry>
        <entry name="aeLock" type="byte" visibility="public" enum="true"
               typedef="boolean">
          <enum>
            <value>OFF
            <notes>Autoexposure lock is disabled; the AE algorithm
            is free to update its parameters.</notes></value>
            <value>ON
            <notes>Autoexposure lock is enabled; the AE algorithm
            must not update the exposure and sensitivity parameters
            while the lock is active</notes></value>
          </enum>
          <description>Whether AE is currently locked to its latest
          calculated values</description>
          <notes>Note that even when AE is locked, the flash may be
          fired if the AE mode is ON_AUTO_FLASH / ON_ALWAYS_FLASH /
          ON_AUTO_FLASH_REDEYE.</notes>
          <tag id="BC" />
        </entry>
        <entry name="aeMode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF
              <notes>Autoexposure is disabled; sensor.exposureTime,
              sensor.sensitivity and sensor.frameDuration are used</notes>
            </value>
            <value>ON
              <notes>Autoexposure is active, no flash
              control</notes>
            </value>
            <value>ON_AUTO_FLASH
            <notes>if flash exists Autoexposure is active, auto
            flash control; flash may be fired when precapture
            trigger is activated, and for captures for which
            captureIntent = STILL_CAPTURE</notes></value>
            <value>ON_ALWAYS_FLASH
            <notes>if flash exists Autoexposure is active, auto
            flash control for precapture trigger and always flash
            when captureIntent = STILL_CAPTURE</notes></value>
            <value>ON_AUTO_FLASH_REDEYE
            <notes>optional Automatic red eye reduction with flash.
            If deemed necessary, red eye reduction sequence should
            fire when precapture trigger is activated, and final
            flash should fire when captureIntent =
            STILL_CAPTURE</notes></value>
          </enum>
          <description>Whether AE is currently updating the sensor
          exposure and sensitivity fields</description>
          <range>android.control.aeAvailableModes</range>
          <notes>Only effective if android.control.mode =
          AUTO</notes>
          <tag id="BC" />
        </entry>
        <entry name="aeRegions" type="int32" visibility="public"
               container="array">
          <array>
            <size>5</size>
            <size>area_count</size>
          </array>
          <description>List of areas to use for
          metering</description>
          <notes>Each area is a rectangle plus weight: xmin, ymin,
          xmax, ymax, weight. The rectangle is defined inclusive of the
          specified coordinates.

          The coordinate system is based on the active pixel array,
          with (0,0) being the top-left pixel in the active pixel array, and
          (android.sensor.info.activeArraySize.width - 1,
          android.sensor.info.activeArraySize.height - 1) being the
          bottom-right pixel in the active pixel array. The weight
          should be nonnegative.

          If all regions have 0 weight, then no specific metering area
          needs to be used by the HAL. If the metering region is
          outside the current android.scaler.cropRegion, the HAL
          should ignore the sections outside the region and output the
          used sections in the frame metadata</notes>
          <tag id="BC" />
        </entry>
        <entry name="aeTargetFpsRange" type="int32" visibility="public"
               container="array">
          <array>
            <size>2</size>
          </array>
          <description>Range over which fps can be adjusted to
          maintain exposure</description>
          <range>android.control.aeAvailableTargetFpsRanges</range>
          <notes>Only constrains AE algorithm, not manual control
          of android.sensor.exposureTime</notes>
          <tag id="BC" />
        </entry>
        <entry name="aePrecaptureTrigger" type="byte" visibility="public"
               enum="true">
          <enum>
            <value>IDLE
              <notes>The trigger is idle.</notes>
            </value>
            <value>START
              <notes>The precapture metering sequence
              must be started. The exact effect of the precapture
              trigger depends on the current AE mode and
              state.</notes>
            </value>
          </enum>
          <description>Whether the HAL must trigger precapture
          metering.</description>
          <notes>This entry is normally set to IDLE, or is not
          included at all in the request settings. When included and
          set to START, the HAL must trigger the autoexposure
          precapture metering sequence.

          The effect of AE precapture trigger depends on the current
          AE mode and state; see the camera HAL device v3 header for
          details.</notes>
          <tag id="BC" />
        </entry>
        <entry name="afMode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF
            <notes>The 3A routines do not control the lens;
            android.lens.focusDistance is controlled by the
            application</notes></value>
            <value>AUTO
            <notes>if lens is not fixed focus.

            Use android.lens.minimumFocusDistance to determine if lens
            is fixed focus In this mode, the lens does not move unless
            the autofocus trigger action is called. When that trigger
            is activated, AF must transition to ACTIVE_SCAN, then to
            the outcome of the scan (FOCUSED or
            NOT_FOCUSED).

            Triggering cancel AF resets the lens position to default,
            and sets the AF state to INACTIVE.</notes></value>
            <value>MACRO
            <notes>In this mode, the lens does not move unless the
            autofocus trigger action is called.

            When that trigger is activated, AF must transition to
            ACTIVE_SCAN, then to the outcome of the scan (FOCUSED or
            NOT_FOCUSED).  Triggering cancel AF resets the lens
            position to default, and sets the AF state to
            INACTIVE.</notes></value>
            <value>CONTINUOUS_VIDEO
            <notes>In this mode, the AF algorithm modifies the lens
            position continually to attempt to provide a
            constantly-in-focus image stream.

            The focusing behavior should be suitable for good quality
            video recording; typically this means slower focus
            movement and no overshoots. When the AF trigger is not
            involved, the AF algorithm should start in INACTIVE state,
            and then transition into PASSIVE_SCAN and PASSIVE_FOCUSED
            states as appropriate. When the AF trigger is activated,
            the algorithm should immediately transition into
            AF_FOCUSED or AF_NOT_FOCUSED as appropriate, and lock the
            lens position until a cancel AF trigger is received.

            Once cancel is received, the algorithm should transition
            back to INACTIVE and resume passive scan. Note that this
            behavior is not identical to CONTINUOUS_PICTURE, since an
            ongoing PASSIVE_SCAN must immediately be
            canceled.</notes></value>
            <value>CONTINUOUS_PICTURE
            <notes>In this mode, the AF algorithm modifies the lens
            position continually to attempt to provide a
            constantly-in-focus image stream.

            The focusing behavior should be suitable for still image
            capture; typically this means focusing as fast as
            possible. When the AF trigger is not involved, the AF
            algorithm should start in INACTIVE state, and then
            transition into PASSIVE_SCAN and PASSIVE_FOCUSED states as
            appropriate as it attempts to maintain focus. When the AF
            trigger is activated, the algorithm should finish its
            PASSIVE_SCAN if active, and then transition into
            AF_FOCUSED or AF_NOT_FOCUSED as appropriate, and lock the
            lens position until a cancel AF trigger is received.

            When the AF cancel trigger is activated, the algorithm
            should transition back to INACTIVE and then act as if it
            has just been started.</notes></value>
            <value>EDOF
            <notes>Extended depth of field (digital focus). AF
            trigger is ignored, AF state should always be
            INACTIVE.</notes></value>
          </enum>
          <description>Whether AF is currently enabled, and what
          mode it is set to</description>
          <tag id="BC" />
        </entry>
        <entry name="afRegions" type="int32" visibility="public"
               container="array">
          <array>
            <size>5</size>
            <size>area_count</size>
          </array>
          <description>List of areas to use for focus
          estimation</description>
          <notes>Each area is a rectangle plus weight: xmin, ymin,
          xmax, ymax, weight. The rectangle is defined inclusive of the
          specified coordinates.

          The coordinate system is based on the active pixel array,
          with (0,0) being the top-left pixel in the active pixel array, and
          (android.sensor.info.activeArraySize.width - 1,
          android.sensor.info.activeArraySize.height - 1) being the
          bottom-right pixel in the active pixel array. The weight
          should be nonnegative.

          If all regions have 0 weight, then no specific focus area
          needs to be used by the HAL. If the focusing region is
          outside the current android.scaler.cropRegion, the HAL
          should ignore the sections outside the region and output the
          used sections in the frame metadata</notes>
          <tag id="BC" />
        </entry>
        <entry name="afTrigger" type="byte" visibility="public" enum="true">
          <enum>
            <value>IDLE
              <notes>The trigger is idle.</notes>
            </value>
            <value>START
              <notes>Autofocus must trigger now.</notes>
            </value>
            <value>CANCEL
              <notes>Autofocus must return to initial
              state, and cancel any active trigger.</notes>
            </value>
          </enum>
          <description>Whether the HAL must trigger autofocus.</description>
          <notes>This entry is normally set to IDLE, or is not
          included at all in the request settings.

          When included and set to START, the HAL must trigger the
          autofocus algorithm. The effect of AF trigger depends on the
          current AF mode and state; see the camera HAL device v3
          header for details. When set to CANCEL, the HAL must cancel
          any active trigger, and return to initial AF state.</notes>
          <tag id="BC" />
        </entry>
        <entry name="awbLock" type="byte" visibility="public" enum="true"
               typedef="boolean">
          <enum>
            <value>OFF
            <notes>Auto-whitebalance lock is disabled; the AWB
            algorithm is free to update its parameters if in AUTO
            mode.</notes></value>
            <value>ON
            <notes>Auto-whitebalance lock is enabled; the AWB
            algorithm must not update the exposure and sensitivity
            parameters while the lock is active</notes></value>
          </enum>
          <description>Whether AWB is currently locked to its
          latest calculated values</description>
          <notes>Note that AWB lock is only meaningful for AUTO
          mode; in other modes, AWB is already fixed to a specific
          setting</notes>
          <tag id="BC" />
        </entry>
        <entry name="awbMode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF</value>
            <value>AUTO</value>
            <value>INCANDESCENT</value>
            <value>FLUORESCENT</value>
            <value>WARM_FLUORESCENT</value>
            <value>DAYLIGHT</value>
            <value>CLOUDY_DAYLIGHT</value>
            <value>TWILIGHT</value>
            <value>SHADE</value>
          </enum>
          <description>Whether AWB is currently setting the color
          transform fields, and what its illumination target
          is</description>
          <notes>[BC - AWB lock,AWB modes]</notes>
          <tag id="BC" />
          <tag id="AWB" />
        </entry>
        <entry name="awbRegions" type="int32" visibility="public"
               container="array">
          <array>
            <size>5</size>
            <size>area_count</size>
          </array>
          <description>List of areas to use for illuminant
          estimation</description>
          <notes>Only used in AUTO mode.

          Each area is a rectangle plus weight: xmin, ymin,
          xmax, ymax, weight. The rectangle is defined inclusive of the
          specified coordinates.

          The coordinate system is based on the active pixel array,
          with (0,0) being the top-left pixel in the active pixel array, and
          (android.sensor.info.activeArraySize.width - 1,
          android.sensor.info.activeArraySize.height - 1) being the
          bottom-right pixel in the active pixel array. The weight
          should be nonnegative.

          If all regions have 0 weight, then no specific metering area
          needs to be used by the HAL. If the metering region is
          outside the current android.scaler.cropRegion, the HAL
          should ignore the sections outside the region and output the
          used sections in the frame metadata</notes>
          <tag id="BC" />
        </entry>
        <entry name="captureIntent" type="byte" visibility="public" enum="true">
          <enum>
            <value>CUSTOM
            <notes>This request doesn't fall into the other
            categories. Default to preview-like
            behavior.</notes></value>
            <value>PREVIEW
            <notes>This request is for a preview-like usecase. The
            precapture trigger may be used to start off a metering
            w/flash sequence</notes></value>
            <value>STILL_CAPTURE
            <notes>This request is for a still capture-type
            usecase.</notes></value>
            <value>VIDEO_RECORD
            <notes>This request is for a video recording
            usecase.</notes></value>
            <value>VIDEO_SNAPSHOT
            <notes>This request is for a video snapshot (still
            image while recording video) usecase</notes></value>
            <value>ZERO_SHUTTER_LAG
            <notes>This request is for a ZSL usecase; the
            application will stream full-resolution images and
            reprocess one or several later for a final
            capture</notes></value>
          </enum>
          <description>Information to 3A routines about the purpose
          of this capture, to help decide optimal 3A
          strategy</description>
          <range>all must be supported</range>
          <notes>Only used if android.control.mode != OFF.</notes>
          <tag id="BC" />
        </entry>
        <entry name="effectMode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF</value>
            <value optional="true">MONO</value>
            <value optional="true">NEGATIVE</value>
            <value optional="true">SOLARIZE</value>
            <value optional="true">SEPIA</value>
            <value optional="true">POSTERIZE</value>
            <value optional="true">WHITEBOARD</value>
            <value optional="true">BLACKBOARD</value>
            <value optional="true">AQUA</value>
          </enum>
          <description>Whether any special color effect is in use.
          Only used if android.control.mode != OFF</description>
          <range>android.control.availableEffects</range>
          <tag id="BC" />
        </entry>
        <entry name="mode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF
            <notes>Full application control of pipeline. All 3A
            routines are disabled, no other settings in
            android.control.* have any effect</notes></value>
            <value>AUTO
            <notes>Use settings for each individual 3A routine.
            Manual control of capture parameters is disabled. All
            controls in android.control.* besides sceneMode take
            effect</notes></value>
            <value>USE_SCENE_MODE
            <notes>Use specific scene mode. Enabling this disables
            control.aeMode, control.awbMode and control.afMode
            controls; the HAL must ignore those settings while
            USE_SCENE_MODE is active (except for FACE_PRIORITY
            scene mode). Other control entries are still active.
            This setting can only be used if availableSceneModes !=
            UNSUPPORTED</notes></value>
          </enum>
          <description>Overall mode of 3A control
          routines</description>
          <range>all must be supported</range>
          <tag id="BC" />
        </entry>
        <entry name="sceneMode" type="byte" visibility="public" enum="true">
          <enum>
            <value id="0">UNSUPPORTED</value>
            <value>FACE_PRIORITY
            <notes>if face detection support exists Use face
            detection data to drive 3A routines. If face detection
            statistics are disabled, should still operate correctly
            (but not return face detection statistics to the
            framework).

            Unlike the other scene modes, aeMode, awbMode, and afMode
            remain active when FACE_PRIORITY is set. This is due to
            compatibility concerns with the old camera
            API</notes></value>
            <value optional="true">ACTION</value>
            <value optional="true">PORTRAIT</value>
            <value optional="true">LANDSCAPE</value>
            <value optional="true">NIGHT</value>
            <value optional="true">NIGHT_PORTRAIT</value>
            <value optional="true">THEATRE</value>
            <value optional="true">BEACH</value>
            <value optional="true">SNOW</value>
            <value optional="true">SUNSET</value>
            <value optional="true">STEADYPHOTO</value>
            <value optional="true">FIREWORKS</value>
            <value optional="true">SPORTS</value>
            <value optional="true">PARTY</value>
            <value optional="true">CANDLELIGHT</value>
            <value optional="true">BARCODE</value>
          </enum>
          <description>Which scene mode is active when
          android.control.mode = SCENE_MODE</description>
          <range>android.control.availableSceneModes</range>
          <tag id="BC" />
        </entry>
        <entry name="videoStabilizationMode" type="byte" visibility="public"
               enum="true" typedef="boolean">
          <enum>
            <value>OFF</value>
            <value>ON</value>
          </enum>
          <description>Whether video stabilization is
          active</description>
          <notes>If enabled, video stabilization can modify the
          android.scaler.cropRegion to keep the video stream
          stabilized</notes>
          <tag id="BC" />
        </entry>
      </controls>
      <static>
        <entry name="aeAvailableAntibandingModes" type="byte" visibility="public"
               type_notes="list of enums" container="array">
          <array>
            <size>n</size>
          </array>
          <description>Which set of antibanding modes are
          supported</description>
        </entry>
        <entry name="aeAvailableModes" type="byte"
        type_notes="list of enums" container="array">
          <array>
            <size>n</size>
          </array>
          <description>Which subset of AE modes is
          supported</description>
          <range>OFF, ON must be supported.
          ON_AUTO_FLASH/ON_ALWAYS_FLASH must be supported if flash
          unit is available</range>
        </entry>
        <entry name="aeAvailableTargetFpsRanges" type="int32" visibility="public"
               type_notes="list of pairs of frame rates"
               container="array">
          <array>
            <size>2</size>
            <size>n</size>
          </array>
          <description>List of frame rate ranges supported by the
          AE algorithm/hardware</description>
        </entry>
        <entry name="aeCompensationRange" type="int32" visibility="public"
               container="array">
          <array>
            <size>2</size>
          </array>
          <description>Maximum and minimum exposure compensation
          setting, in counts of
          android.control.aeCompensationStepSize</description>
          <range>At least (-2,2)/(exp compensation step
          size)</range>
          <tag id="BC" />
        </entry>
        <entry name="aeCompensationStep" type="rational" visibility="public">
          <description>Smallest step by which exposure compensation
          can be changed</description>
          <range>&lt;= 1/2</range>
          <tag id="BC" />
        </entry>
        <entry name="afAvailableModes" type="byte" visibility="public"
        type_notes="List of enums" container="array">
          <array>
            <size>n</size>
          </array>
          <description>List of AF modes that can be
          selected</description>
          <range>OFF must be included. AUTO must be supported if
          lens allows for changing focus</range>
          <tag id="BC" />
        </entry>
        <entry name="availableEffects" type="byte" visibility="public"
               type_notes="list of enums" container="array">
          <array>
            <size>n</size>
          </array>
          <description>what subset of the full color effect enum
          list is supported</description>
          <range>OFF must be listed</range>
          <tag id="BC" />
        </entry>
        <entry name="availableSceneModes" type="byte" visibility="public"
               type_notes="list of enums from android.control.sceneMode, plus UNSUPPORTED to indicate no scene modes are supported"
               container="array">
          <array>
            <size>n</size>
          </array>
          <description>what subset of the scene mode enum list is
          supported.</description>
          <range>SCENE_MODE_FACE_PRIORITY must be supported if face
          detection is supported</range>
          <tag id="BC" />
        </entry>
        <entry name="availableVideoStabilizationModes" type="byte"
               visibility="public" type_notes="List of enums." container="array">
          <array>
            <size>n</size>
          </array>
          <description>List of video stabilization modes that can
          be supported</description>
          <range>OFF must be included</range>
          <tag id="BC" />
        </entry>
        <entry name="awbAvailableModes" type="byte" visibility="public"
               type_notes="List of enums (android.control.awbMode)"
               container="array">
          <array>
            <size>n</size>
          </array>
          <range>OFF, AUTO must be included</range>
          <tag id="BC" />
        </entry>
        <entry name="maxRegions" type="int32" visibility="public">
          <description>For AE, AWB, and AF, how many individual
          regions can be listed for metering?</description>
          <range>&gt;= 1</range>
          <tag id="BC" />
        </entry>
        <entry name="sceneModeOverrides" type="byte" visibility="system"
               container="array">
          <array>
            <size>3</size>
            <size>length(availableSceneModes)</size>
          </array>
          <description>List of AE, AWB, and AF modes to use for
          each available scene mode</description>
          <range>For each listed scene mode, lists the aeMode,
          awbMode, and afMode that the HAL wants to use for that
          scene mode.

          For each entry, the order is {aeMode, awbMode, afMode} in
          order of increasing index</range>
          <notes>When a scene mode is enabled, the HAL is expected
          to override aeMode, awbMode, and afMode with its
          preferred settings for that scene mode.

          To simplify communication with old camera API applications,
          the service wants this override list in the static metadata.
          The order of this list matches that of availableSceneModes,
          with 3 entires for each scene mode.  The overrides listed
          for SCENE_MODE_FACE_PRIORITY are ignored, since for that
          mode, the application-set aeMode, awbMode, and afMode are
          used instead, like they are when android.control.mode is
          AUTO.

          It is recommended that for FACE_PRIORITY, the overrides
          should be set to 0. As an example, if availableSceneModes is
          { FACE_PRIORITY, ACTION, NIGHT }, then the service expects
          this field to have 9 entries; for example { 0 , 0, 0,
          ON_AUTO_FLASH, AUTO, CONTINUOUS_PICTURE, ON_AUTO_FLASH,
          INCANDESCENT, AUTO }</notes>
          <tag id="BC" />
        </entry>
      </static>
      <dynamic>
        <entry name="aePrecaptureId" type="int32" visibility="hidden">
          <description>The ID sent with the latest
          CAMERA2_TRIGGER_PRECAPTURE_METERING call</description>
          <notes>Must be 0 if no
          CAMERA2_TRIGGER_PRECAPTURE_METERING trigger received yet
          by HAL. Always updated even if AE algorithm ignores the
          trigger</notes>
        </entry>
        <clone entry="android.control.aeRegions" kind="controls">
        </clone>
        <entry name="aeState" type="byte" visibility="public" enum="true">
          <enum>
            <value>INACTIVE
            <notes>AE is off.  When a camera device is opened, it starts in
            this state.</notes></value>
            <value>SEARCHING
            <notes>AE doesn't yet have a good set of control values
            for the current scene</notes></value>
            <value>CONVERGED
            <notes>AE has a good set of control values for the
            current scene</notes></value>
            <value>LOCKED
            <notes>AE has been locked (aeMode =
            LOCKED)</notes></value>
            <value>FLASH_REQUIRED
            <notes>AE has a good set of control values, but flash
            needs to be fired for good quality still
            capture</notes></value>
            <value>PRECAPTURE
            <notes>AE has been asked to do a precapture sequence
            (through the
            trigger_action(CAMERA2_TRIGGER_PRECAPTURE_METERING)
            call), and is currently executing it. Once PRECAPTURE
            completes, AE will transition to CONVERGED or
            FLASH_REQUIRED as appropriate</notes></value>
          </enum>
          <description>Current state of AE algorithm</description>
          <notes>Whenever the AE algorithm state changes, a
          MSG_AUTOEXPOSURE notification must be send if a
          notification callback is registered.</notes>
        </entry>
        <clone entry="android.control.afMode" kind="controls">
        </clone>
        <clone entry="android.control.afRegions" kind="controls">
        </clone>
        <entry name="afState" type="byte" visibility="public" enum="true">
          <enum>
            <value>INACTIVE
            <notes>AF off or has not yet tried to scan/been asked
            to scan.  When a camera device is opened, it starts in
            this state.</notes></value>
            <value>PASSIVE_SCAN
            <notes>if CONTINUOUS_* modes are supported. AF is
            currently doing an AF scan initiated by a continuous
            autofocus mode</notes></value>
            <value>PASSIVE_FOCUSED
            <notes>if CONTINUOUS_* modes are supported. AF currently
            believes it is in focus, but may restart scanning at
            any time.</notes></value>
            <value>ACTIVE_SCAN
            <notes>if AUTO or MACRO modes are supported. AF is doing
            an AF scan because it was triggered by AF
            trigger</notes></value>
            <value>FOCUSED_LOCKED
            <notes>if any AF mode besides OFF is supported. AF
            believes it is focused correctly and is
            locked</notes></value>
            <value>NOT_FOCUSED_LOCKED
            <notes>if any AF mode besides OFF is supported. AF has
            failed to focus successfully and is
            locked</notes></value>
            <value>PASSIVE_UNFOCUSED
            <notes>if CONTINUOUS_* modes are supported. AF finished a
            passive scan without finding focus, and may restart
            scanning at any time.</notes></value>
          </enum>
          <description>Current state of AF algorithm</description>
          <notes>Whenever the AF algorithm state changes, a
          MSG_AUTOFOCUS notification must be send if a notification
          callback is registered.</notes>
        </entry>
        <entry name="afTriggerId" type="int32" visibility="hidden">
          <description>The ID sent with the latest
          CAMERA2_TRIGGER_AUTOFOCUS call</description>
          <notes>Must be 0 if no CAMERA2_TRIGGER_AUTOFOCUS trigger
          received yet by HAL. Always updated even if AF algorithm
          ignores the trigger</notes>
        </entry>
        <clone entry="android.control.awbMode" kind="controls">
        </clone>
        <clone entry="android.control.awbRegions" kind="controls">
        </clone>
        <entry name="awbState" type="byte" visibility="public" enum="true">
          <enum>
            <value>INACTIVE
            <notes>AWB is not in auto mode.  When a camera device is opened, it
            starts in this state.</notes></value>
            <value>SEARCHING
            <notes>AWB doesn't yet have a good set of control
            values for the current scene</notes></value>
            <value>CONVERGED
            <notes>AWB has a good set of control values for the
            current scene</notes></value>
            <value>LOCKED
            <notes>AE has been locked (aeMode =
            LOCKED)</notes></value>
          </enum>
          <description>Current state of AWB algorithm</description>
          <notes>Whenever the AWB algorithm state changes, a
          MSG_AUTOWHITEBALANCE notification must be send if a
          notification callback is registered.</notes>
        </entry>
        <clone entry="android.control.mode" kind="controls">
        </clone>
      </dynamic>
    </section>
    <section name="demosaic">
      <controls>
        <entry name="mode" type="byte" enum="true">
          <enum>
            <value>FAST
            <notes>Minimal or no slowdown of frame rate compared to
            Bayer RAW output</notes></value>
            <value>HIGH_QUALITY
            <notes>High-quality may reduce output frame
            rate</notes></value>
          </enum>
          <description>Controls the quality of the demosaicing
          processing</description>
          <tag id="V1" />
        </entry>
      </controls>
    </section>
    <section name="edge">
      <controls>
        <entry name="mode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF
            <notes>No edge enhancement is applied</notes></value>
            <value>FAST
            <notes>Must not slow down frame rate relative to raw
            bayer output</notes></value>
            <value>HIGH_QUALITY
            <notes>Frame rate may be reduced by high
            quality</notes></value>
          </enum>
          <description>Operation mode for edge
          enhancement</description>
        </entry>
        <entry name="strength" type="byte">
          <description>Control the amount of edge enhancement
          applied to the images</description>
          <units>1-10; 10 is maximum sharpening</units>
        </entry>
      </controls>
      <dynamic>
        <clone entry="android.edge.mode" kind="controls"></clone>
      </dynamic>
    </section>
    <section name="flash">
      <controls>
        <entry name="firingPower" type="byte">
          <description>Power for flash firing/torch</description>
          <units>10 is max power; 0 is no flash. Linear</units>
          <range>0 - 10</range>
          <notes>Power for snapshot may use a different scale than
          for torch mode. Only one entry for torch mode will be
          used</notes>
          <tag id="V1" />
        </entry>
        <entry name="firingTime" type="int64">
          <description>Firing time of flash relative to start of
          exposure</description>
          <units>nanoseconds</units>
          <range>0-(exposure time-flash duration)</range>
          <notes>Clamped to (0, exposure time - flash
          duration).</notes>
          <tag id="V1" />
        </entry>
        <entry name="mode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF
            <notes>Do not fire the flash for this
            capture</notes></value>
            <value>SINGLE
            <notes>if android.flash.available is true Fire flash
            for this capture based on firingPower,
            firingTime.</notes></value>
            <value>TORCH
            <notes>if android.flash.available is true Flash
            continuously on, power set by
            firingPower</notes></value>
          </enum>
          <description>Select flash operation mode</description>
          <tag id="BC" />
        </entry>
      </controls>
      <static>
        <namespace name="info">
          <entry name="available" type="byte" visibility="public">
            <description>Whether this camera has a
            flash</description>
            <units>boolean (0 = false, otherwise true)</units>
            <notes>If no flash, none of the flash controls do
            anything. All other metadata should return 0</notes>
            <tag id="BC" />
          </entry>
          <entry name="chargeDuration" type="int64">
            <description>Time taken before flash can fire
            again</description>
            <units>nanoseconds</units>
            <range>0-1e9</range>
            <notes>1 second too long/too short for recharge? Should
            this be power-dependent?</notes>
            <tag id="V1" />
          </entry>
        </namespace>
        <entry name="colorTemperature" type="byte">
          <description>The x,y whitepoint of the
          flash</description>
          <units>pair of floats</units>
          <range>0-1 for both</range>
          <tag id="ADV" />
        </entry>
        <entry name="maxEnergy" type="byte">
          <description>Max energy output of the flash for a full
          power single flash</description>
          <units>lumen-seconds</units>
          <range>&gt;= 0</range>
          <tag id="ADV" />
        </entry>
      </static>
      <dynamic>
        <clone entry="android.flash.firingPower" kind="controls">
        </clone>
        <clone entry="android.flash.firingTime" kind="controls">
        </clone>
        <clone entry="android.flash.mode" kind="controls"></clone>
        <entry name="state" type="byte" visibility="public" enum="true">
          <enum>
            <value>UNAVAILABLE
            <notes>No flash on camera</notes></value>
            <value>CHARGING
            <notes>if android.flash.available is true Flash is
            charging and cannot be fired</notes></value>
            <value>READY
            <notes>if android.flash.available is true Flash is
            ready to fire</notes></value>
            <value>FIRED
            <notes>if android.flash.available is true Flash fired
            for this capture</notes></value>
          </enum>
          <description>Current state of the flash
          unit</description>
        </entry>
      </dynamic>
    </section>
    <section name="geometric">
      <controls>
        <entry name="mode" type="byte" enum="true">
          <enum>
            <value>OFF
            <notes>No geometric correction is
            applied</notes></value>
            <value>FAST
            <notes>Must not slow down frame rate relative to raw
            bayer output</notes></value>
            <value>HIGH_QUALITY
            <notes>Frame rate may be reduced by high
            quality</notes></value>
          </enum>
          <description>Operating mode of geometric
          correction</description>
        </entry>
        <entry name="strength" type="byte">
          <description>Control the amount of shading correction
          applied to the images</description>
          <units>unitless: 1-10; 10 is full shading
          compensation</units>
          <tag id="ADV" />
        </entry>
      </controls>
    </section>
    <section name="hotPixel">
      <controls>
        <entry name="mode" type="byte" enum="true">
          <enum>
            <value>OFF
            <notes>No hot pixel correction can be
            applied</notes></value>
            <value>FAST
            <notes>Frame rate must not be reduced compared to raw
            Bayer output</notes></value>
            <value>HIGH_QUALITY
            <notes>Frame rate may be reduced by high
            quality</notes></value>
          </enum>
          <description>Set operational mode for hot pixel
          correction</description>
          <tag id="V1" />
        </entry>
      </controls>
      <static>
        <namespace name="info">
          <entry name="map" type="int32"
          type_notes="list of coordinates based on android.sensor.pixelArraySize"
          container="array">
            <array>
              <size>2</size>
              <size>n</size>
            </array>
            <description>Location of hot/defective pixels on
            sensor</description>
            <tag id="ADV" />
          </entry>
        </namespace>
      </static>
      <dynamic>
        <clone entry="android.hotPixel.mode" kind="controls">
          <tag id="V1" />
        </clone>
      </dynamic>
    </section>
    <section name="jpeg">
      <controls>
        <entry name="gpsCoordinates" type="double" visibility="public"
        type_notes="latitude, longitude, altitude. First two in degrees, the third in meters"
        container="array">
          <array>
            <size>3</size>
          </array>
          <description>GPS coordinates to include in output JPEG
          EXIF</description>
          <range>(-180 - 180], [-90,90], [-inf, inf]</range>
          <tag id="BC" />
        </entry>
        <entry name="gpsProcessingMethod" type="byte" visibility="public"
               typedef="string">
          <description>32 characters describing GPS algorithm to
          include in EXIF</description>
          <units>UTF-8 null-terminated string</units>
          <tag id="BC" />
        </entry>
        <entry name="gpsTimestamp" type="int64" visibility="public">
          <description>Time GPS fix was made to include in
          EXIF</description>
          <units>UTC in seconds since January 1, 1970</units>
          <tag id="BC" />
        </entry>
        <entry name="orientation" type="int32" visibility="public">
          <description>Orientation of JPEG image to
          write</description>
          <units>Degrees in multiples of 90</units>
          <range>0, 90, 180, 270</range>
          <tag id="BC" />
        </entry>
        <entry name="quality" type="byte" visibility="public">
          <description>Compression quality of the final JPEG
          image</description>
          <range>1-100; larger is higher quality</range>
          <notes>85-95 is typical usage range</notes>
          <tag id="BC" />
        </entry>
        <entry name="thumbnailQuality" type="byte" visibility="public">
          <description>Compression quality of JPEG
          thumbnail</description>
          <range>1-100; larger is higher quality</range>
          <tag id="BC" />
        </entry>
        <entry name="thumbnailSize" type="int32" visibility="public"
        container="array" typedef="size">
          <array>
            <size>2</size>
          </array>
          <description>Resolution of embedded JPEG
          thumbnail</description>
          <range>from android.jpeg.availableThumbnailSizes</range>
          <tag id="BC" />
        </entry>
      </controls>
      <static>
        <entry name="availableThumbnailSizes" type="int32" visibility="public"
        type_notes="list of resolution pairs" container="array" typedef="size">
          <array>
            <size>2</size>
            <size>n</size>
          </array>
          <description>Supported resolutions for the JPEG
          thumbnail</description>
          <range>Must include at least one valid resolution, plus
          (0,0) for no thumbnail generation</range>
          <tag id="BC" />
        </entry>
        <entry name="maxSize" type="int32" visibility="system">
          <description>Maximum size in bytes for the compressed
          JPEG buffer</description>
          <range>Must be large enough to fit any JPEG produced by
          the camera</range>
          <notes>This is used for sizing the gralloc buffers for
          JPEG</notes>
        </entry>
      </static>
      <dynamic>
        <clone entry="android.jpeg.gpsCoordinates" kind="controls">
        </clone>
        <clone entry="android.jpeg.gpsProcessingMethod"
        kind="controls"></clone>
        <clone entry="android.jpeg.gpsTimestamp" kind="controls">
        </clone>
        <clone entry="android.jpeg.orientation" kind="controls">
        </clone>
        <clone entry="android.jpeg.quality" kind="controls">
        </clone>
        <entry name="size" type="int32">
          <description>The size of the compressed JPEG image, in
          bytes</description>
          <range>&gt;= 0</range>
          <notes>If no JPEG output is produced for the request,
          this must be 0.

          Otherwise, this describes the real size of the compressed
          JPEG image placed in the output stream.  More specifically,
          if android.jpeg.maxSize = 1000000, and a specific capture
          has android.jpeg.size = 500000, then the output buffer from
          the JPEG stream will be 1000000 bytes, of which the first
          500000 make up the real data.</notes>
        </entry>
        <clone entry="android.jpeg.thumbnailQuality"
        kind="controls"></clone>
        <clone entry="android.jpeg.thumbnailSize" kind="controls">
        </clone>
      </dynamic>
    </section>
    <section name="lens">
      <controls>
        <entry name="aperture" type="float" visibility="public">
          <description>Size of the lens aperture</description>
          <units>f-number (f/NNN)</units>
          <range>android.lens.info.availableApertures</range>
          <notes>Will not be supported on most devices. Can only
          pick from supported list</notes>
          <tag id="V1" />
        </entry>
        <entry name="filterDensity" type="float" visibility="public">
          <description>State of lens neutral density
          filter(s)</description>
          <units>number of stops of filtering</units>
          <range>android.lens.info.availableFilterDensities</range>
          <notes>Will not be supported on most devices. Can only
          pick from supported list</notes>
          <tag id="V1" />
        </entry>
        <entry name="focalLength" type="float" visibility="public">
          <description>Lens optical zoom setting</description>
          <units>focal length in mm</units>
          <range>&gt; 0</range>
          <notes>Will not be supported on most devices.</notes>
          <tag id="V1" />
        </entry>
        <entry name="focusDistance" type="float" visibility="public">
          <description>Distance to plane of sharpest focus,
          measured from frontmost surface of the lens</description>
          <units>diopters (1/m)</units>
          <range>&gt;= 0</range>
          <notes>0 = infinity focus. Used value should be clamped
          to (0,minimum focus distance)</notes>
          <tag id="BC" />
          <tag id="V1" />
        </entry>
        <entry name="opticalStabilizationMode" type="byte" visibility="public"
        enum="true">
          <enum>
            <value>OFF</value>
            <value optional="true">ON</value>
          </enum>
          <description>Whether optical image stabilization is
          enabled.</description>
          <range>android.lens.availableOpticalStabilization</range>
          <notes>Will not be supported on most devices.</notes>
          <tag id="V1" />
        </entry>
      </controls>
      <static>
        <namespace name="info">
          <entry name="availableApertures" type="float" visibility="public"
          container="array">
            <array>
              <size>n</size>
            </array>
            <description>List of supported aperture
            values</description>
            <range>one entry required, &gt; 0</range>
            <notes>If variable aperture not available, only setting
            should be for the fixed aperture</notes>
            <tag id="V1" />
          </entry>
          <entry name="availableFilterDensities" type="float" visibility="public"
          container="array">
            <array>
              <size>n</size>
            </array>
            <description>List of supported ND filter
            values</description>
            <range>one entry required, &gt;= 0</range>
            <notes>If not available, only setting is 0. Otherwise,
            lists the available exposure index values for dimming
            (2 would mean the filter is set to reduce incoming
            light by two stops)</notes>
            <tag id="V1" />
          </entry>
          <entry name="availableFocalLengths" type="float" visibility="public"
          type_notes="the list of available focal lengths"
          container="array">
            <array>
              <size>n</size>
            </array>
            <description>If fitted with optical zoom, what focal
            lengths are available. If not, the static focal
            length</description>
            <range>&gt; 0</range>
            <notes>If optical zoom not supported, only one value
            should be reported</notes>
            <tag id="BC" />
            <tag id="V1" />
          </entry>
          <entry name="availableOpticalStabilization" type="byte"
          visibility="public" type_notes="list of enums" container="array">
            <array>
              <size>n</size>
            </array>
            <description>List of supported optical image
            stabilization modes</description>
            <tag id="V1" />
          </entry>
          <entry name="geometricCorrectionMap" type="float"
          type_notes="2D array of destination coordinate pairs for uniform grid points in source image, per color channel. Size in the range of 2x3x40x30"
          container="array">
            <array>
              <size>2</size>
              <size>3</size>
              <size>n</size>
              <size>m</size>
            </array>
            <description>A low-resolution map for correction of
            geometric distortions and chromatic aberrations, per
            color channel</description>
            <range>N, M &gt;= 2</range>
            <notes>[DNG wants a function instead]. What's easiest
            for implementers? With an array size (M, N), entry (i,
            j) provides the destination for pixel (i/(M-1) * width,
            j/(N-1) * height). Data is row-major, with each array
            entry being ( (X, Y)_r, (X, Y)_g, (X, Y)_b ) )</notes>
            <tag id="DNG" />
          </entry>
          <entry name="geometricCorrectionMapSize" type="int32"
          type_notes="width and height of geometric correction map"
          container="array" typedef="size">
            <array>
              <size>2</size>
            </array>
            <description>Dimensions of geometric correction
            map</description>
            <range>Both values &gt;= 2</range>
            <tag id="V1" />
          </entry>
          <entry name="hyperfocalDistance" type="float" visibility="public">
            <description>Hyperfocal distance for this lens; set to
            0 if fixed focus</description>
            <units>diopters</units>
            <range>&gt;= 0</range>
            <notes>The hyperfocal distance is used for the old
            API's 'fixed' setting</notes>
            <tag id="BC" />
          </entry>
          <entry name="minimumFocusDistance" type="float" visibility="public">
            <description>Shortest distance from frontmost surface
            of the lens that can be focused correctly</description>
            <units>diopters</units>
            <range>&gt;= 0</range>
            <notes>If the lens is fixed-focus, this should be
            0</notes>
            <tag id="V1" />
          </entry>
          <entry name="shadingMapSize" type="int32" visibility="public"
                 type_notes="width and height of lens shading map provided by the HAL. (N, M)"
                 container="array" typedef="size">
            <array>
              <size>2</size>
            </array>
            <description>Dimensions of lens shading
            map</description>
            <range>Both values &gt;= 1</range>
            <tag id="V1" />
          </entry>
        </namespace>
        <entry name="facing" type="byte" visibility="public" enum="true">
          <enum>
            <value>FRONT</value>
            <value>BACK</value>
          </enum>
          <description>Direction the camera faces relative to
          device screen</description>
        </entry>
        <entry name="opticalAxisAngle" type="float"
        type_notes="degrees. First defines the angle of separation between the perpendicular to the screen and the camera optical axis. The second then defines the clockwise rotation of the optical axis from native device up."
        container="array">
          <array>
            <size>2</size>
          </array>
          <description>Relative angle of camera optical axis to the
          perpendicular axis from the display</description>
          <range>[0-90) for first angle, [0-360) for second</range>
          <notes>Examples:

          (0,0) means that the camera optical axis
          is perpendicular to the display surface;

          (45,0) means that the camera points 45 degrees up when
          device is held upright;

          (45,90) means the camera points 45 degrees to the right when
          the device is held upright.

          Use FACING field to determine perpendicular outgoing
          direction</notes>
          <tag id="ADV" />
        </entry>
        <entry name="position" type="float" container="array">
          <array>
            <size>3, location in mm, in the sensor coordinate
            system</size>
          </array>
          <description>Coordinates of camera optical axis on
          device</description>
          <tag id="V1" />
        </entry>
      </static>
      <dynamic>
        <clone entry="android.lens.aperture" kind="controls">
          <tag id="V1" />
        </clone>
        <clone entry="android.lens.filterDensity" kind="controls">
          <tag id="V1" />
        </clone>
        <clone entry="android.lens.focalLength" kind="controls">
          <tag id="BC" />
        </clone>
        <clone entry="android.lens.focusDistance" kind="controls">
          <notes>Should be zero for fixed-focus cameras</notes>
          <tag id="BC" />
        </clone>
        <entry name="focusRange" type="float" visibility="public"
        type_notes="Range of scene distances that are in focus"
        container="array">
          <array>
            <size>2</size>
          </array>
          <description>The range of scene distances that are in
          sharp focus (depth of field)</description>
          <units>pair of focus distances in diopters: (near,
          far)</units>
          <range>&gt;=0</range>
          <notes>If variable focus not supported, can still report
          fixed depth of field range</notes>
          <tag id="BC" />
        </entry>
        <clone entry="android.lens.opticalStabilizationMode"
        kind="controls">
          <tag id="V1" />
        </clone>
        <entry name="state" type="byte" visibility="public" enum="true">
          <enum>
            <value>STATIONARY</value>
            <value>MOVING</value>
          </enum>
          <description>Current lens status</description>
          <tag id="V1" />
        </entry>
      </dynamic>
    </section>
    <section name="noiseReduction">
      <controls>
        <entry name="mode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF
            <notes>No noise reduction is applied</notes></value>
            <value>FAST
            <notes>Must not slow down frame rate relative to raw
            bayer output</notes></value>
            <value>HIGH_QUALITY
            <notes>May slow down frame rate to provide highest
            quality</notes></value>
          </enum>
          <description>Mode of operation for the noise reduction
          algorithm</description>
          <range>android.noiseReduction.availableModes</range>
          <tag id="V1" />
        </entry>
        <entry name="strength" type="byte">
          <description>Control the amount of noise reduction
          applied to the images</description>
          <units>1-10; 10 is max noise reduction</units>
          <range>1 - 10</range>
        </entry>
      </controls>
      <dynamic>
        <clone entry="android.noiseReduction.mode" kind="controls">
        </clone>
      </dynamic>
    </section>
    <section name="quirks">
      <static>
        <entry name="meteringCropRegion" type="byte" visibility="system" optional="true">
          <description>If set to 1, the camera service does not
          scale 'normalized' coordinates with respect to the crop
          region. This applies to metering input (a{e,f,wb}Region
          and output (face rectangles).</description>
          <notes>Normalized coordinates refer to those in the
          (-1000,1000) range mentioned in the
          android.hardware.Camera API.

          HAL implementations should instead always use and emit
          sensor array-relative coordinates for all region data. Does
          not need to be listed in static metadata. Support will be
          removed in future versions of camera service.</notes>
        </entry>
        <entry name="triggerAfWithAuto" type="byte" visibility="system" optional="true">
          <description>If set to 1, then the camera service always
          switches to FOCUS_MODE_AUTO before issuing a AF
          trigger.</description>
          <notes>HAL implementations should implement AF trigger
          modes for AUTO, MACRO, CONTINUOUS_FOCUS, and
          CONTINUOUS_PICTURE modes instead of using this flag. Does
          not need to be listed in static metadata. Support will be
          removed in future versions of camera service</notes>
        </entry>
        <entry name="useZslFormat" type="byte" visibility="system" optional="true">
          <description>If set to 1, the camera service uses
          CAMERA2_PIXEL_FORMAT_ZSL instead of
          HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED for the zero
          shutter lag stream</description>
          <notes>HAL implementations should use gralloc usage flags
          to determine that a stream will be used for
          zero-shutter-lag, instead of relying on an explicit
          format setting. Does not need to be listed in static
          metadata. Support will be removed in future versions of
          camera service.</notes>
        </entry>
        <entry name="usePartialResult" type="byte" visibility="hidden" optional="true">
          <description>If set to 1, the HAL will always split result
          metadata for a single capture into multiple buffers,
          returned using multiple process_capture_result calls.
          </description>
          <notes>Does not need to be listed in static
          metadata. Support for partial results will be reworked in
          future versions of camera service. This quirk will stop
          working at that point; DO NOT USE without careful
          consideration of future support.
          </notes>
        </entry>

      </static>
      <dynamic>
        <entry name="partialResult" type="byte" visibility="hidden" optional="true" enum="true" typedef="boolean">
          <enum>
            <value>FINAL
            <notes>The last or only metadata result buffer
            for this capture.</notes>
            </value>
            <value>PARTIAL
            <notes>A partial buffer of result metadata for this
            capture. More result buffers for this capture will be sent
            by the HAL, the last of which will be marked
            FINAL.</notes>
            </value>
          </enum>
          <description>Whether a result given to the framework is the
          final one for the capture, or only a partial that contains a
          subset of the full set of dynamic metadata
          values.</description>
          <range>Optional. Default value is FINAL.</range>
          <notes>The entries in the result metadata buffers for a
          single capture may not overlap, except for this entry. The
          FINAL buffers must retain FIFO ordering relative to the
          requests that generate them, so the FINAL buffer for frame 3 must
          always be sent to the framework after the FINAL buffer for frame 2, and
          before the FINAL buffer for frame 4. PARTIAL buffers may be returned
          in any order relative to other frames, but all PARTIAL buffers for a given
          capture must arrive before the FINAL buffer for that capture. This entry may
          only be used by the HAL if quirks.usePartialResult is set to 1.
          </notes>
        </entry>
      </dynamic>
    </section>
    <section name="request">
      <controls>
        <entry name="frameCount" type="int32" visibility="system">
          <description>A frame counter set by the framework. Must
          be maintained unchanged in output frame. This value monotonically
          increases with every new result (that is, each new result has a unique
          frameCount value).
          </description>
          <units>incrementing integer</units>
          <range>Any int</range>
        </entry>
        <entry name="id" type="int32" visibility="hidden">
          <description>An application-specified ID for the current
          request. Must be maintained unchanged in output
          frame</description>
          <units>arbitrary integer assigned by application</units>
          <range>Any int</range>
          <tag id="V1" />
        </entry>
        <entry name="inputStreams" type="int32" visibility="system"
               container="array">
          <array>
            <size>n</size>
          </array>
          <description>List which camera reprocess stream is used
          for the source of reprocessing data.</description>
          <units>List of camera reprocess stream IDs</units>
          <range>Typically, only one entry allowed, must be a valid
          reprocess stream ID.

          If android.jpeg.needsThumbnail is set, then multiple
          reprocess streams may be included in a single request; they
          must be different scaled versions of the same image.</range>
          <notes>Only meaningful when android.request.type ==
          REPROCESS. Ignored otherwise</notes>
          <tag id="HAL2" />
        </entry>
        <entry name="metadataMode" type="byte" visibility="system"
               enum="true">
          <enum>
            <value>NONE
            <notes>No metadata should be produced on output, except
            for application-bound buffer data. If no
            application-bound streams exist, no frame should be
            placed in the output frame queue. If such streams
            exist, a frame should be placed on the output queue
            with null metadata but with the necessary output buffer
            information. Timestamp information should still be
            included with any output stream buffers</notes></value>
            <value>FULL
            <notes>All metadata should be produced. Statistics will
            only be produced if they are separately
            enabled</notes></value>
          </enum>
          <description>How much metadata to produce on
          output</description>
        </entry>
        <entry name="outputStreams" type="int32" visibility="system"
               container="array">
          <array>
            <size>n</size>
          </array>
          <description>Lists which camera output streams image data
          from this capture must be sent to</description>
          <units>List of camera stream IDs</units>
          <range>List must only include streams that have been
          created</range>
          <notes>If no output streams are listed, then the image
          data should simply be discarded. The image data must
          still be captured for metadata and statistics production,
          and the lens and flash must operate as requested.</notes>
          <tag id="HAL2" />
        </entry>
        <entry name="type" type="byte" visibility="system" enum="true">
          <enum>
            <value>CAPTURE
            <notes>Capture a new image from the imaging hardware,
            and process it according to the
            settings</notes></value>
            <value>REPROCESS
            <notes>Process previously captured data; the
            android.request.inputStream parameter determines the
            source reprocessing stream. TODO: Mark dynamic metadata
            needed for reprocessing with [RP]</notes></value>
          </enum>
          <description>The type of the request; either CAPTURE or
          REPROCESS. For HAL3, this tag is redundant.</description>
          <tag id="HAL2" />
        </entry>
      </controls>
      <static>
        <entry name="maxNumOutputStreams" type="int32" visibility="public"
        container="array">
          <array>
            <size>3</size>
          </array>
          <description>How many output streams can be allocated at
          the same time for each type of stream</description>
          <units>The number of raw sensor streams; the number of
          processed, uncompressed streams; and the number of
          JPEG-compressed streams</units>
          <range>&gt;=1 for Raw and JPEG-compressed stream. &gt;= 3
          for processed, uncompressed streams</range>
          <notes>Video snapshot with preview callbacks requires 3
          processed streams (preview, record, app callbacks) and
          one JPEG stream (snapshot)</notes>
          <tag id="BC" />
        </entry>
        <entry name="maxNumReprocessStreams" type="int32" visibility="system"
        container="array">
          <array>
            <size>1</size>
          </array>
          <description>How many reprocessing streams of any type
          can be allocated at the same time</description>
          <range>&gt;= 1</range>
        </entry>
      </static>
      <dynamic>
        <entry name="frameCount" type="int32" visibility="public">
          <description>A frame counter set by the framework. This value monotonically
          increases with every new result (that is, each new result has a unique
          frameCount value).</description>
          <units>count of frames</units>
          <range>&gt; 0</range>
          <notes>Reset on release()</notes>
        </entry>
        <clone entry="android.request.id" kind="controls"></clone>
        <clone entry="android.request.metadataMode"
        kind="controls"></clone>
        <clone entry="android.request.outputStreams"
        kind="controls"></clone>
      </dynamic>
    </section>
    <section name="scaler">
      <controls>
        <entry name="cropRegion" type="int32" visibility="public"
               container="array" typedef="rectangle">
          <array>
            <size>4</size>
          </array>
          <description>(x, y, width, height).

          A rectangle with the top-level corner of (x,y) and size
          (width, height). The region of the sensor that is used for
          output. Each stream must use this rectangle to produce its
          output, cropping to a smaller region if necessary to
          maintain the stream's aspect ratio.

          HAL2.x uses only (x, y, width)</description>
          <units>(x,y) of top-left corner, width and height of region
          in pixels; (0,0) is top-left corner of
          android.sensor.activeArraySize</units>
          <notes>
            Any additional per-stream cropping must be done to
            maximize the final pixel area of the stream.

            For example, if the crop region is set to a 4:3 aspect
            ratio, then 4:3 streams should use the exact crop
            region. 16:9 streams should further crop vertically
            (letterbox).

            Conversely, if the crop region is set to a 16:9, then 4:3
            outputs should crop horizontally (pillarbox), and 16:9
            streams should match exactly. These additional crops must
            be centered within the crop region.

            The output streams must maintain square pixels at all
            times, no matter what the relative aspect ratios of the
            crop region and the stream are.  Negative values for
            corner are allowed for raw output if full pixel array is
            larger than active pixel array. Width and height may be
            rounded to nearest larger supportable width, especially
            for raw output, where only a few fixed scales may be
            possible. The width and height of the crop region cannot
            be set to be smaller than floor( activeArraySize.width /
            android.scaler.maxDigitalZoom ) and floor(
            activeArraySize.height / android.scaler.maxDigitalZoom),
            respectively.
          </notes>
          <tag id="BC" />
        </entry>
      </controls>
      <static>
        <entry name="availableFormats" type="int32"
        visibility="public" enum="true"
        type_notes="values from HAL_PIXEL_FORMAT_* in /system/core/include/system/graphics.h"
        container="array" typedef="imageFormat">
          <array>
            <size>n</size>
          </array>
          <enum>
            <value id="0x20">RAW_SENSOR
            </value>
            <value id="0x32315659">YV12
                <notes>YCrCb 4:2:0 Planar</notes>
            </value>
            <value id="0x11">YCrCb_420_SP
                <notes>NV21</notes>
            </value>

            <value id="0x22">IMPLEMENTATION_DEFINED
                <notes>Hal Implementation Defined</notes>
            </value>

            <value id="0x23">YCbCr_420_888
                <notes>Flexible YUV420 Format</notes>
            </value>

            <value id="0x21">BLOB
                <notes>JPEG</notes>
            </value>
          </enum>
          <description>List of app-visible formats</description>
          <tag id="BC" />
        </entry>
        <entry name="availableJpegMinDurations" type="int64" visibility="public"
        container="array">
          <array>
            <size>n</size>
          </array>
          <description>The minimum frame duration that is supported
          for each resolution in availableJpegSizes. Should
          correspond to the frame duration when only that JPEG
          stream is active and captured in a burst, with all
          processing set to FAST</description>
          <notes>When multiple streams are configured, the minimum
          frame duration will be &gt;= max(individual stream min
          durations)</notes>
          <tag id="BC" />
        </entry>
        <entry name="availableJpegSizes" type="int32" visibility="public"
        container="array" typedef="size">
          <array>
            <size>n</size>
            <size>2</size>
          </array>
          <description>The resolutions available for output from
          the JPEG block. Listed as width x height</description>
          <range>Must include: - sensor maximum resolution Should
          include: - half/quarter max resolution</range>
          <tag id="BC" />
        </entry>
        <entry name="availableMaxDigitalZoom" type="float" visibility="public">
          <description>The maximum ratio between active area width
          and crop region width, or between active area height and
          crop region height, if the crop region height is larger
          than width</description>
          <range>&gt;=1</range>
          <tag id="BC" />
        </entry>
        <entry name="availableProcessedMinDurations" type="int64" visibility="public"
        container="array">
          <array>
            <size>n</size>
          </array>
          <description>The minimum frame duration that is supported
          for each resolution in availableProcessedSizes. Should
          correspond to the frame duration when only that processed
          stream is active, with all processing set to
          FAST</description>
          <notes>When multiple streams are configured, the minimum
          frame duration will be &gt;= max(individual stream min
          durations)</notes>
          <tag id="BC" />
        </entry>
        <entry name="availableProcessedSizes" type="int32" visibility="public"
        container="array" typedef="size">
          <array>
            <size>n</size>
            <size>2</size>
          </array>
          <description>The resolutions available for use with
          processed output streams, such as YV12, NV12, and
          platform opaque YUV/RGB streams to the GPU or video
          encoders. Listed as width, height</description>
          <range>Must include: - sensor maximum resolution -
          standard QCIF, 240p, 480p, 720p, and 1080p
          resolutions</range>
          <notes>The actual supported resolution list may be limited by
          consumer end points for different use cases. For example, for
          recording use case, the largest supported resolution may be
          limited by max supported size from encoder, for preview use
          case, the largest supported resolution may be limited by max
          resolution SurfaceTexture/SurfaceView can support.
          </notes>
          <tag id="BC" />
        </entry>
        <entry name="availableRawMinDurations" type="int64"
        container="array">
          <array>
            <size>n</size>
          </array>
          <description>The minimum frame duration that is supported
          for each raw resolution in availableRawSizes. Should
          correspond to the frame duration when only the raw stream
          is active.</description>
          <notes>When multiple streams are configured, the minimum
          frame duration will be &gt;= max(individual stream min
          durations)</notes>
          <tag id="BC" />
        </entry>
        <entry name="availableRawSizes" type="int32"
        container="array" typedef="size">
          <array>
            <size>n</size>
            <size>2</size>
          </array>
          <description>The resolutions available for use with raw
          sensor output streams, listed as width,
          height</description>
          <range>Must include: - sensor maximum resolution</range>
        </entry>
      </static>
      <dynamic>
        <clone entry="android.scaler.cropRegion" kind="controls">
        </clone>
      </dynamic>
    </section>
    <section name="sensor">
      <controls>
        <entry name="exposureTime" type="int64" visibility="public">
          <description>Duration each pixel is exposed to
          light.

          If the sensor can't expose this exact duration, it should shorten the
          duration exposed to the nearest possible value (rather than expose longer).
          </description>
          <units>nanoseconds</units>
          <range>android.sensor.info.exposureTimeRange</range>
          <notes>1/10000 - 30 sec range. No bulb mode</notes>
          <tag id="V1" />
        </entry>
        <entry name="frameDuration" type="int64" visibility="public">
          <description>Duration from start of frame exposure to
          start of next frame exposure</description>
          <units>nanoseconds</units>
          <range>see android.sensor.info.maxFrameDuration,
          android.scaler.info.availableMinFrameDurations</range>
          <notes>Exposure time has priority, so duration is set to
          max(duration, exposure time + overhead)</notes>
          <tag id="V1" />
          <tag id="BC" />
        </entry>
        <entry name="sensitivity" type="int32" visibility="public">
          <description>Gain applied to image data. Must be
          implemented through analog gain only if set to values
          below 'maximum analog sensitivity'.

          If the sensor can't apply this exact gain, it should lessen the
          gain to the nearest possible value (rather than gain more).
          </description>
          <units>ISO arithmetic units</units>
          <range>android.sensor.info.sensitivityRange</range>
          <notes>ISO 12232:2006 REI method</notes>
          <tag id="V1" />
        </entry>
      </controls>
      <static>
        <namespace name="info">
          <entry name="activeArraySize" type="int32" visibility="public"
          type_notes="Four ints defining the active pixel rectangle"
          container="array"
          typedef="rectangle">
            <array>
              <size>4</size>
            </array>
            <description>Area of raw data which corresponds to only
            active pixels; smaller or equal to
            pixelArraySize.</description>
            <units>xmin, ymin, width, height. Top left of full
            pixel array is (0,0)</units>
            <tag id="DNG" />
          </entry>
          <entry name="sensitivityRange" type="int32" visibility="public"
          type_notes="Range of supported sensitivities"
          container="array">
            <array>
              <size>2</size>
            </array>
            <description>Range of valid sensitivities</description>
            <range>Min &lt;= 100, Max &gt;= 1600</range>
            <tag id="BC" />
            <tag id="V1" />
          </entry>
          <entry name="colorFilterArrangement" type="byte" enum="true">
            <enum>
              <value>RGGB</value>
              <value>GRBG</value>
              <value>GBRG</value>
              <value>BGGR</value>
              <value>RGB
              <notes>Sensor is not Bayer; output has 3 16-bit
              values for each pixel, instead of just 1 16-bit value
              per pixel.</notes></value>
            </enum>
            <description>Arrangement of color filters on sensor;
            represents the colors in the top-left 2x2 section of
            the sensor, in reading order</description>
            <tag id="DNG" />
          </entry>
          <entry name="exposureTimeRange" type="int64" visibility="public"
          type_notes="nanoseconds" container="array">
            <array>
              <size>2</size>
            </array>
            <description>Range of valid exposure
            times</description>
            <range>Min &lt;= 100e3 (100 us), Max &gt;= 30e9 (30
            sec)</range>
            <tag id="V1" />
          </entry>
          <entry name="maxFrameDuration" type="int64" visibility="public">
            <description>Maximum possible frame duration (minimum frame
            rate)</description>
            <units>nanoseconds</units>
            <range>&gt;= 30e9</range>
            <notes>Minimum duration is a function of resolution,
            processing settings. See
            android.scaler.availableProcessedMinDurations
            android.scaler.availableJpegMinDurations
            android.scaler.availableRawMinDurations</notes>
            <tag id="BC" />
            <tag id="V1" />
          </entry>
          <entry name="physicalSize" type="float" visibility="public"
          type_notes="width x height in millimeters"
          container="array">
            <array>
              <size>2</size>
            </array>
            <description>The physical dimensions of the full pixel
            array</description>
            <notes>Needed for FOV calculation for old API</notes>
            <tag id="V1" />
            <tag id="BC" />
          </entry>
          <entry name="pixelArraySize" type="int32"
          container="array" typedef="size">
            <array>
              <size>2</size>
            </array>
            <description>Dimensions of full pixel array, possibly
            including black calibration pixels</description>
            <notes>Maximum output resolution for raw format must
            match this in
            android.scaler.info.availableSizesPerFormat</notes>
            <tag id="DNG" />
            <tag id="BC" />
          </entry>
          <entry name="whiteLevel" type="int32">
            <description>Maximum raw value output by
            sensor</description>
            <range>&gt; 1024 (10-bit output)</range>
            <notes>Defines sensor bit depth (10-14 bits is
            expected)</notes>
            <tag id="DNG" />
          </entry>
        </namespace>
        <entry name="baseGainFactor" type="rational" visibility="public"
        optional="true">
          <description>Gain factor from electrons to raw units when
          ISO=100</description>
          <tag id="V1" />
          <tag id="FULL" />
        </entry>
        <entry name="blackLevelPattern" type="int32"
        type_notes="2x2 raw count block" container="array">
          <array>
            <size>4</size>
          </array>
          <description>A fixed black level offset for each of the
          Bayer mosaic channels</description>
          <range>&gt;= 0 each</range>
          <notes>As per DNG BlackLevelRepeatDim / BlackLevel
          tags</notes>
          <tag id="DNG" />
        </entry>
        <entry name="calibrationTransform1" type="rational"
        type_notes="3x3 matrix in row-major-order"
        container="array">
          <array>
            <size>9</size>
          </array>
          <description>Per-device calibration on top of color space
          transform 1</description>
          <tag id="DNG" />
        </entry>
        <entry name="calibrationTransform2" type="rational"
        type_notes="3x3 matrix in row-major-order"
        container="array">
          <array>
            <size>9</size>
          </array>
          <description>Per-device calibration on top of color space
          transform 2</description>
          <tag id="DNG" />
        </entry>
        <entry name="colorTransform1" type="rational"
        type_notes="3x3 matrix in row-major-order"
        container="array">
          <array>
            <size>9</size>
          </array>
          <description>Linear mapping from XYZ (D50) color space to
          reference linear sensor color, for first reference
          illuminant</description>
          <notes>Use as follows XYZ = inv(transform) * clip( (raw -
          black level(raw) ) / ( white level - max black level) ).
          At least in the simple case</notes>
          <tag id="DNG" />
        </entry>
        <entry name="colorTransform2" type="rational"
        type_notes="3x3 matrix in row-major-order"
        container="array">
          <array>
            <size>9</size>
          </array>
          <description>Linear mapping from XYZ (D50) color space to
          reference linear sensor color, for second reference
          illuminant</description>
          <tag id="DNG" />
        </entry>
        <entry name="forwardMatrix1" type="rational"
        type_notes="3x3 matrix in row-major-order"
        container="array">
          <array>
            <size>9</size>
          </array>
          <description>Used by DNG for better WB
          adaptation</description>
          <tag id="DNG" />
        </entry>
        <entry name="forwardMatrix2" type="rational"
        type_notes="3x3 matrix in row-major-order"
        container="array">
          <array>
            <size>9</size>
          </array>
          <description>Used by DNG for better WB
          adaptation</description>
          <tag id="DNG" />
        </entry>
        <entry name="maxAnalogSensitivity" type="int32" visibility="public"
        optional="true">
          <description>Maximum sensitivity that is implemented
          purely through analog gain</description>
          <notes>For android.sensor.sensitivity values less than or
          equal to this, all applied gain must be analog. For
          values above this, it can be a mix of analog and
          digital</notes>
          <tag id="V1" />
          <tag id="FULL" />
        </entry>
        <entry name="noiseModelCoefficients" type="float"
        type_notes="float constants A, B for the noise variance model"
        container="array">
          <array>
            <size>2</size>
          </array>
          <description>Estimation of sensor noise
          characteristics</description>
          <units>var(raw pixel value) = electrons * (baseGainFactor
          * iso/100)^2 + A * (baseGainFactor * iso/100)^2 +
          B</units>
          <notes>A represents sensor read noise before analog
          amplification; B represents noise from A/D conversion and
          other circuits after amplification. Both noise sources
          are assumed to be gaussian, independent, and not to vary
          across the sensor</notes>
          <tag id="V1" />
        </entry>
        <entry name="orientation" type="int32" visibility="public">
          <description>Clockwise angle through which the output
          image needs to be rotated to be upright on the device
          screen in its native orientation. Also defines the
          direction of rolling shutter readout, which is from top
          to bottom in the sensor's coordinate system</description>
          <units>degrees clockwise rotation, only multiples of
          90</units>
          <range>0,90,180,270</range>
          <tag id="BC" />
        </entry>
        <entry name="referenceIlluminant1" type="byte" enum="true">
          <enum>
            <value id="1">DAYLIGHT</value>
            <value id="2">FLUORESCENT</value>
            <value id="3">TUNGSTEN
            <notes>Incandescent light</notes></value>
            <value id="4">FLASH</value>
            <value id="9">FINE_WEATHER</value>
            <value id="10">CLOUDY_WEATHER</value>
            <value id="11">SHADE</value>
            <value id="12">DAYLIGHT_FLUORESCENT
            <notes>D 5700 - 7100K</notes></value>
            <value id="13">DAY_WHITE_FLUORESCENT
            <notes>N 4600 - 5400K</notes></value>
            <value id="14">COOL_WHITE_FLUORESCENT
            <notes>W 3900 - 4500K</notes></value>
            <value id="15">WHITE_FLUORESCENT
            <notes>WW 3200 - 3700K</notes></value>
            <value id="17">STANDARD_A</value>
            <value id="18">STANDARD_B</value>
            <value id="19">STANDARD_C</value>
            <value id="20">D55</value>
            <value id="21">D65</value>
            <value id="22">D75</value>
            <value id="23">D50</value>
            <value id="24">ISO_STUDIO_TUNGSTEN</value>
          </enum>
          <description>Light source used to define transform
          1</description>
          <notes>[EXIF LightSource tag] Must all these be
          supported? Need CCT for each!</notes>
          <tag id="DNG" />
          <tag id="EXIF" />
        </entry>
        <entry name="referenceIlluminant2" type="byte">
          <description>Light source used to define transform
          2</description>
          <units>Same as illuminant 1</units>
        </entry>
      </static>
      <dynamic>
        <clone entry="android.sensor.exposureTime" kind="controls">
        </clone>
        <clone entry="android.sensor.frameDuration"
        kind="controls"></clone>
        <clone entry="android.sensor.sensitivity" kind="controls">
        </clone>
        <entry name="timestamp" type="int64" visibility="public">
          <description>Time at start of exposure of first
          row</description>
          <units>nanoseconds</units>
          <range>&gt; 0</range>
          <notes>Monotonic, should be synced to other timestamps in
          system</notes>
          <tag id="BC" />
        </entry>
        <entry name="temperature" type="float" visibility="public"
        optional="true">
          <description>The temperature of the sensor, sampled at the time
          exposure began for this frame.

          The thermal diode being queried should be inside the sensor PCB, or
          somewhere close to it.
          </description>

          <units>celsius</units>
          <range>Optional. This value is missing if no temperature is available.</range>
          <tag id="FULL" />
        </entry>
      </dynamic>
    </section>
    <section name="shading">
      <controls>
        <entry name="mode" type="byte" enum="true">
          <enum>
            <value>OFF
            <notes>No shading correction is applied</notes></value>
            <value>FAST
            <notes>Must not slow down frame rate relative to raw
            bayer output</notes></value>
            <value>HIGH_QUALITY
            <notes>Frame rate may be reduced by high
            quality</notes></value>
          </enum>
          <description>Quality of lens shading correction applied
          to the image data</description>
        </entry>
        <entry name="strength" type="byte">
          <description>Control the amount of shading correction
          applied to the images</description>
          <units>unitless: 1-10; 10 is full shading
          compensation</units>
          <tag id="ADV" />
        </entry>
      </controls>
      <dynamic>
        <clone entry="android.shading.mode" kind="controls">
        </clone>
      </dynamic>
    </section>
    <section name="statistics">
      <controls>
        <entry name="faceDetectMode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF</value>
            <value>SIMPLE
            <notes>Optional Return rectangle and confidence
            only</notes></value>
            <value>FULL
            <notes>Optional Return all face
            metadata</notes></value>
          </enum>
          <description>State of the face detector
          unit</description>
          <range>
          android.statistics.info.availableFaceDetectModes</range>
          <notes>Whether face detection is enabled, and whether it
          should output just the basic fields or the full set of
          fields. Value must be one of the
          android.statistics.info.availableFaceDetectModes.</notes>
          <tag id="BC" />
        </entry>
        <entry name="histogramMode" type="byte" enum="true" typedef="boolean">
          <enum>
            <value>OFF</value>
            <value>ON</value>
          </enum>
          <description>Operating mode for histogram
          generation</description>
          <tag id="V1" />
        </entry>
        <entry name="sharpnessMapMode" type="byte" enum="true" typedef="boolean">
          <enum>
            <value>OFF</value>
            <value>ON</value>
          </enum>
          <description>Operating mode for sharpness map
          generation</description>
          <tag id="V1" />
        </entry>
      </controls>
      <static>
        <namespace name="info">
          <entry name="availableFaceDetectModes" type="byte"
                 visibility="public"
                 type_notes="List of enums from android.statistics.faceDetectMode"
                 container="array">
            <array>
              <size>n</size>
            </array>
            <description>Which face detection modes are available,
            if any</description>
            <units>List of enum:
            OFF
            SIMPLE
            FULL</units>
            <notes>OFF means face detection is disabled, it must
            be included in the list.

            SIMPLE means the device supports the
            android.statistics.faceRectangles and
            android.statistics.faceScores outputs.

            FULL means the device additionally supports the
            android.statistics.faceIds and
            android.statistics.faceLandmarks outputs.
            </notes>
          </entry>
          <entry name="histogramBucketCount" type="int32">
            <description>Number of histogram buckets
            supported</description>
            <range>&gt;= 64</range>
          </entry>
          <entry name="maxFaceCount" type="int32" visibility="public" >
            <description>Maximum number of simultaneously detectable
            faces</description>
            <range>&gt;= 4 if availableFaceDetectionModes lists
            modes besides OFF, otherwise 0</range>
          </entry>
          <entry name="maxHistogramCount" type="int32">
            <description>Maximum value possible for a histogram
            bucket</description>
          </entry>
          <entry name="maxSharpnessMapValue" type="int32">
            <description>Maximum value possible for a sharpness map
            region.</description>
          </entry>
          <entry name="sharpnessMapSize" type="int32"
          type_notes="width x height" container="array" typedef="size">
            <array>
              <size>2</size>
            </array>
            <description>Dimensions of the sharpness
            map</description>
            <range>Must be at least 32 x 32</range>
          </entry>
        </namespace>
      </static>
      <dynamic>
        <clone entry="android.statistics.faceDetectMode"
        kind="controls"></clone>
        <entry name="faceIds" type="int32" visibility="public" container="array">
          <array>
            <size>n</size>
          </array>
          <description>List of unique IDs for detected
          faces</description>
          <notes>Only available if faceDetectMode == FULL</notes>
          <tag id="BC" />
        </entry>
        <entry name="faceLandmarks" type="int32" visibility="public"
        type_notes="(leftEyeX, leftEyeY, rightEyeX, rightEyeY, mouthX, mouthY)"
        container="array">
          <array>
            <size>n</size>
            <size>6</size>
          </array>
          <description>List of landmarks for detected
          faces</description>
          <notes>Only available if faceDetectMode == FULL</notes>
          <tag id="BC" />
        </entry>
        <entry name="faceRectangles" type="int32" visibility="public"
        type_notes="(xmin, ymin, xmax, ymax). (0,0) is top-left of active pixel area"
        container="array" typedef="rectangle">
          <array>
            <size>n</size>
            <size>4</size>
          </array>
          <description>List of the bounding rectangles for detected
          faces</description>
          <notes>Only available if faceDetectMode != OFF</notes>
          <tag id="BC" />
        </entry>
        <entry name="faceScores" type="byte" visibility="public" container="array">
          <array>
            <size>n</size>
          </array>
          <description>List of the face confidence scores for
          detected faces</description>
          <range>1-100</range>
          <notes>Only available if faceDetectMode != OFF. The value should be
          meaningful (for example, setting 100 at all times is illegal).</notes>
          <tag id="BC" />
        </entry>
        <entry name="histogram" type="int32"
        type_notes="count of pixels for each color channel that fall into each histogram bucket, scaled to be between 0 and maxHistogramCount"
        container="array">
          <array>
            <size>n</size>
            <size>3</size>
          </array>
          <description>A 3-channel histogram based on the raw
          sensor data</description>
          <notes>The k'th bucket (0-based) covers the input range
          (with w = android.sensor.info.whiteLevel) of [ k * w/N,
          (k + 1) * w / N ). If only a monochrome sharpness map is
          supported, all channels should have the same data</notes>
          <tag id="V1" />
        </entry>
        <clone entry="android.statistics.histogramMode"
        kind="controls"></clone>
        <entry name="sharpnessMap" type="int32"
        type_notes="estimated sharpness for each region of the input image. Normalized to be between 0 and maxSharpnessMapValue. Higher values mean sharper (better focused)"
        container="array">
          <array>
            <size>n</size>
            <size>m</size>
            <size>3</size>
          </array>
          <description>A 3-channel sharpness map, based on the raw
          sensor data</description>
          <notes>If only a monochrome sharpness map is supported,
          all channels should have the same data</notes>
          <tag id="V1" />
        </entry>
        <clone entry="android.statistics.sharpnessMapMode"
        kind="controls"></clone>
        <entry name="lensShadingMap" type="float" visibility="public"
               type_notes="2D array of float gain factors per channel to correct lens shading"
               container="array">
          <array>
            <size>4</size>
            <size>n</size>
            <size>m</size>
          </array>
          <description>A low-resolution map of lens shading, per
          color channel</description>
          <range>Each gain factor is &gt;= 1</range>
          <notes>Assume bilinear interpolation of map. The least
          shaded section of the image should have a gain factor
          of 1; all other sections should have gains above 1.
          the map should be on the order of 30-40 rows, and
          must be smaller than 64x64.

          When android.colorCorrection.mode = TRANSFORM_MATRIX, the map
          must take into account the colorCorrection settings.
          </notes>
        </entry>
        <entry name="predictedColorGains" type="float" visibility="public"
               type_notes="A 1D array of floats for 4 color channel gains"
               container="array">
          <array>
            <size>4</size>
          </array>
          <description>The best-fit color channel gains calculated
          by the HAL's statistics units for the current output frame
          </description>
          <notes>
          This may be different than the gains used for this frame,
          since statistics processing on data from a new frame
          typically completes after the transform has already been
          applied to that frame.

          The 4 channel gains are defined in Bayer domain,
          see android.colorCorrection.gains for details.

          This value should always be calculated by the AWB block,
          regardless of the android.control.* current values.
          </notes>
        </entry>
        <entry name="predictedColorTransform" type="rational" visibility="public"
               type_notes="3x3 rational matrix in row-major order"
               container="array">
          <array>
            <size>3</size>
            <size>3</size>
          </array>
          <description>The best-fit color transform matrix estimate
          calculated by the HAL's statistics units for the current
          output frame</description>
          <notes>The HAL must provide the estimate from its
          statistics unit on the white balance transforms to use
          for the next frame. These are the values the HAL believes
          are the best fit for the current output frame. This may
          be different than the transform used for this frame, since
          statistics processing on data from a new frame typically
          completes after the transform has already been applied to
          that frame.

          These estimates must be provided for all frames, even if
          capture settings and color transforms are set by the application.

          This value should always be calculated by the AWB block,
          regardless of the android.control.* current values.
          </notes>
        </entry>
        <entry name="sceneFlicker" type="byte" visibility="public" enum="true">
          <enum>
            <value>NONE</value>
            <value>50HZ</value>
            <value>60HZ</value>
          </enum>
          <description>The HAL estimated scene illumination lighting
          frequency</description>
          <notes>Report NONE if there doesn't appear to be flickering
          illumination</notes>
        </entry>
      </dynamic>
      <controls>
        <entry name="lensShadingMapMode" type="byte" visibility="public" enum="true">
          <enum>
            <value>OFF</value>
            <value>ON</value>
          </enum>
          <description>Whether the HAL needs to output the lens
          shading map in output result metadata</description>
          <notes>When set to ON,
          android.statistics.lensShadingMap must be provided in
          the output result metdata.</notes>
        </entry>
      </controls>
    </section>
    <section name="tonemap">
      <controls>
        <entry name="curveBlue" type="float" visibility="public"
        type_notes="1D array of float pairs (P_IN, P_OUT). The maximum number of pairs is specified by android.tonemap.maxCurvePoints."
        container="array">
          <array>
            <size>n</size>
            <size>2</size>
          </array>
          <description>Table mapping blue input values to output
          values</description>
          <units>same as android.tonemap.curveRed</units>
          <range>same as android.tonemap.curveRed</range>
          <notes>Tonemapping / contrast / gamma curve for the blue
          channel, to use when android.tonemap.mode is CONTRAST_CURVE.

          See android.tonemap.curveRed for more details.</notes>
        </entry>
        <entry name="curveGreen" type="float" visibility="public"
        type_notes="1D array of float pairs (P_IN, P_OUT). The maximum number of pairs is specified by android.tonemap.maxCurvePoints."
        container="array">
          <array>
            <size>n</size>
            <size>2</size>
          </array>
          <description>Table mapping green input values to output
          values</description>
          <units>same as android.tonemap.curveRed</units>
          <range>same as android.tonemap.curveRed</range>
          <notes>Tonemapping / contrast / gamma curve for the green
          channel, to use when android.tonemap.mode is CONTRAST_CURVE.

          See android.tonemap.curveRed for more details.</notes>
        </entry>
        <entry name="curveRed" type="float" visibility="public"
        type_notes="1D array of float pairs (P_IN, P_OUT). The maximum number of pairs is specified by android.tonemap.maxCurvePoints."
        container="array">
          <array>
            <size>n</size>
            <size>2</size>
          </array>
          <description>Table mapping red input values to output
          values</description>
          <range>0-1 on input and output coordinates.</range>
          <notes>Tonemapping / contrast / gamma curve for the red
          channel, to use when android.tonemap.mode is CONTRAST_CURVE.

          Since the input and output ranges may vary depending on
          the camera pipeline, the input and output pixel values
          are represented by normalized floating-point values
          between 0 and 1, with 0 == black and 1 == white.

          The curve should be linearly interpolated between the
          defined points. The points will be listed in increasing
          order of P_IN. For example, if the array is: [0.0, 0.0,
          0.3, 0.5, 1.0, 1.0], then the input-&gt;output mapping
          for a few sample points would be: 0 -&gt; 0, 0.15 -&gt;
          0.25, 0.3 -&gt; 0.5, 0.5 -&gt; 0.64</notes>
          <tag id="DNG" />
        </entry>
        <entry name="mode" type="byte" visibility="public" enum="true">
          <enum>
            <value>CONTRAST_CURVE
            <notes>Use the tone mapping curve specified in
            android.tonemap.curve</notes></value>
            <value>FAST
            <notes>Must not slow down frame rate relative to raw
            bayer output</notes></value>
            <value>HIGH_QUALITY
            <notes>Frame rate may be reduced by high
            quality</notes></value>
          </enum>
        </entry>
      </controls>
      <static>
        <entry name="maxCurvePoints" type="int32" visibility="public" >
          <description>Maximum number of supported points in the
          tonemap curve</description>
          <range>&gt;= 128</range>
        </entry>
      </static>
      <dynamic>
        <clone entry="android.tonemap.curveBlue" kind="controls">
        </clone>
        <clone entry="android.tonemap.curveGreen" kind="controls">
        </clone>
        <clone entry="android.tonemap.curveRed" kind="controls">
        </clone>
        <clone entry="android.tonemap.mode" kind="controls">
        </clone>
      </dynamic>
    </section>
    <section name="led">
      <controls>
        <entry name="transmit" type="byte" visibility="hidden" enum="true"
               typedef="boolean">
          <enum>
            <value>OFF</value>
            <value>ON</value>
          </enum>
          <description>This LED is nominally used to indicate to the user
          that the camera is powered on and may be streaming images back to the
          Application Processor. In certain rare circumstances, the OS may
          disable this when video is processed locally and not transmitted to
          any untrusted applications.

          In particular, the LED *must* always be on when the data could be
          transmitted off the device. The LED *should* always be on whenever
          data is stored locally on the device.

          The LED *may* be off if a trusted application is using the data that
          doesn't violate the above rules.
          </description>
        </entry>
      </controls>
      <dynamic>
        <clone entry="android.led.transmit" kind="controls"></clone>
      </dynamic>
      <static>
        <entry name="availableLeds" type="byte" visibility="hidden" enum="true"
               container="array">
          <array>
            <size>n</size>
          </array>
          <enum>
            <value>TRANSMIT
              <notes>android.led.transmit control is used</notes>
            </value>
          </enum>
          <description>A list of camera LEDs that are available on this system.
          </description>
        </entry>
      </static>
    </section>
    <section name="info">
      <static>
        <entry name="supportedHardwareLevel" type="byte" visibility="public"
               enum="true" >
          <enum>
            <value>LIMITED</value>
            <value>FULL</value>
          </enum>
          <description>
          The camera 3 HAL device can implement one of two possible
          operational modes; limited and full. Full support is
          expected from new higher-end devices. Limited mode has
          hardware requirements roughly in line with those for a
          camera HAL device v1 implementation, and is expected from
          older or inexpensive devices. Full is a strict superset of
          limited, and they share the same essential operational flow.

          For full details refer to "S3. Operational Modes" in camera3.h
          </description>
          <range>Optional. Default value is LIMITED.</range>
        </entry>
      </static>
    </section>
    <section name="blackLevel">
      <controls>
        <entry name="lock" type="byte" visibility="public" enum="true"
               typedef="boolean">
          <enum>
            <value>OFF</value>
            <value>ON</value>
          </enum>
          <description> Whether black-level compensation is locked
          to its current values, or is free to vary</description>
          <notes>When set to ON, the values used for black-level
          compensation must not change until the lock is set to
          OFF

          Since changes to certain capture parameters (such as
          exposure time) may require resetting of black level
          compensation, the HAL must report whether setting the
          black level lock was successful in the output result
          metadata.

          The black level locking must happen at the sensor, and not at the ISP.
          If for some reason black level locking is no longer legal (for example,
          the analog gain has changed, which forces black levels to be
          recalculated), then the HAL is free to override this request (and it
          must report 'OFF' when this does happen) until the next time locking
          is legal again.</notes>
          <tag id="HAL2" />
        </entry>
      </controls>
      <dynamic>
        <clone entry="android.blackLevel.lock"
        kind="controls"></clone>
      </dynamic>
    </section>
  </namespace>
</metadata>
